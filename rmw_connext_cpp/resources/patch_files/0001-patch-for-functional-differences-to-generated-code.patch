From 75284eee62dd86075a781cade020926cf3518c95 Mon Sep 17 00:00:00 2001
From: Karsten Knese <karsten.knese@googlemail.com>
Date: Mon, 5 Mar 2018 16:35:17 -0800
Subject: [PATCH] patch for functional differences to generated code

---
 .../connext_static_raw_dataPlugin.cxx              | 295 +++++++++------------
 .../connext_static_raw_dataPlugin.h                |   3 +
 .../connext_static_raw_dataSupport.cxx             |  59 +++++
 .../connext_static_raw_dataSupport.h               |  99 ++++++-
 4 files changed, 288 insertions(+), 168 deletions(-)

diff --git a/rmw_connext_cpp/resources/patch_generated/connext_static_raw_dataPlugin.cxx b/rmw_connext_cpp/resources/patch_generated/connext_static_raw_dataPlugin.cxx
index 78b58d5..831d83f 100644
--- a/rmw_connext_cpp/resources/patch_generated/connext_static_raw_dataPlugin.cxx
+++ b/rmw_connext_cpp/resources/patch_generated/connext_static_raw_dataPlugin.cxx
@@ -379,74 +379,81 @@ ConnextStaticRawDataPlugin_serialize(
     RTIBool serialize_sample, 
     void *endpoint_plugin_qos)
 {
-    char * position = NULL;
-    RTIBool retval = RTI_TRUE;
-
-    if (endpoint_data) {} /* To avoid warnings */
-    if (endpoint_plugin_qos) {} /* To avoid warnings */
-
-    if(serialize_encapsulation) {
-        if (!RTICdrStream_serializeAndSetCdrEncapsulation(stream , encapsulation_id)) {
-            return RTI_FALSE;
-        }
+  char * position = NULL;
+  RTIBool retval = RTI_TRUE;
+
+  if (endpoint_data) {}   /* To avoid warnings */
+  if (endpoint_plugin_qos) {}   /* To avoid warnings */
+
+  /* This plugin can only be used to publish the top-level DDS Topic-Type
+   * in which case serialize_encapsulation==TRUE. If that is not
+   * the case then it is an error.
+   */
+  if (!serialize_encapsulation) {
+    return RTI_FALSE;
+  }
+
+  position = RTICdrStream_resetAlignment(stream);
+
+  if (serialize_sample) {
+    /* The sample->serialized_data contains the serialized encapsulation followed by the serialized
+     * data, so we only need to copy that into
+     * the CDR stream. Not the key_hash, not the length of the data itself
+     * The SerializedType sample->serialized_data is always a contiguous buffer
+     */
+    DDS_Octet * buffer = DDS_OctetSeq_get_contiguous_bufferI(&sample->serialized_data);
+    if (buffer == NULL) {
+      return RTI_FALSE;
+    }
 
-        position = RTICdrStream_resetAlignment(stream);
+    /* The encapsulation_id appears in the sample->serialized_data as octet[2] using big-endian
+     * byte order
+     */
+    if (encapsulation_id != (buffer[0] * 256 + buffer[1]) ) {
+      return RTI_FALSE;
     }
 
-    if(serialize_sample) {
+    /* Use RTICdrStream_serializePrimitiveArray so that there is no additional length prepended */
+    if (!RTICdrStream_serializePrimitiveArray(
+        stream, (void *)buffer,
+        DDS_OctetSeq_get_length(&sample->serialized_data),
+        RTI_CDR_OCTET_TYPE))
+    {
+      return RTI_FALSE;
+    }
+  }
 
-        if (!RTICdrStream_serializePrimitiveArray(
-            stream, (void*) sample->key_hash, ((KEY_HASH_LENGTH_16)), RTI_CDR_OCTET_TYPE)) {
-            return RTI_FALSE;
-        }
+  RTICdrStream_restoreAlignment(stream, position);
 
-        if (DDS_OctetSeq_get_contiguous_bufferI(&sample->serialized_key) != NULL) {
-            if (!RTICdrStream_serializePrimitiveSequence(
-                stream,
-                DDS_OctetSeq_get_contiguous_bufferI(&sample->serialized_key),
-                DDS_OctetSeq_get_length(&sample->serialized_key),
-                (RTI_INT32_MAX-1),
-                RTI_CDR_OCTET_TYPE)) {
-                return RTI_FALSE;
-            } 
-        } else {
-            if (!RTICdrStream_serializePrimitivePointerSequence(
-                stream,
-                (const void **) DDS_OctetSeq_get_discontiguous_bufferI(&sample->serialized_key),
-                DDS_OctetSeq_get_length(&sample->serialized_key),
-                (RTI_INT32_MAX-1), 
-                RTI_CDR_OCTET_TYPE)) {
-                return RTI_FALSE;
-            } 
-        }
-
-        if (DDS_OctetSeq_get_contiguous_bufferI(&sample->serialized_data) != NULL) {
-            if (!RTICdrStream_serializePrimitiveSequence(
-                stream,
-                DDS_OctetSeq_get_contiguous_bufferI(&sample->serialized_data),
-                DDS_OctetSeq_get_length(&sample->serialized_data),
-                (RTI_INT32_MAX-1),
-                RTI_CDR_OCTET_TYPE)) {
-                return RTI_FALSE;
-            } 
-        } else {
-            if (!RTICdrStream_serializePrimitivePointerSequence(
-                stream,
-                (const void **) DDS_OctetSeq_get_discontiguous_bufferI(&sample->serialized_data),
-                DDS_OctetSeq_get_length(&sample->serialized_data),
-                (RTI_INT32_MAX-1), 
-                RTI_CDR_OCTET_TYPE)) {
-                return RTI_FALSE;
-            } 
-        }
+  return retval;
+}
 
-    }
+/**
+    TODO. The code-block below does not belong here.
+    It should be pushed to the CDR module, perhaps inside
+    RTICdrStream_deserializeAndSetCdrEncapsulation so that the
+    stream size is alredy correct when SerializedTypePlugin_deserialize_sample
+    is called.
 
-    if(serialize_encapsulation) {
-        RTICdrStream_restoreAlignment(stream,position);
-    }
+    Adjust the size of the CDR stream to not include the alignment
+    padding. See http://issues.omg.org/browse/DDSXTY12-10
 
-    return retval;
+    @precondition The RTICdrStream *stream has alreadt processed
+                  the encapsulation header and therefore has set the
+                  encapsulation options returned by
+                  RTICdrStream_getEncapsulationOptions()
+*/
+void
+ConnextStaticRawDataPlugin_remove_padding_from_stream(struct RTICdrStream * stream)
+{
+  /* See http://issues.omg.org/browse/DDSXTY12-10 */
+  DDS_UnsignedShort padding_size_mask = 0x0003;
+  DDS_UnsignedShort padding_size;
+  int adjustedBufferLength;
+
+  padding_size = RTICdrStream_getEncapsulationOptions(stream) & padding_size_mask;
+  adjustedBufferLength = RTICdrStream_getBufferLength(stream) - padding_size;
+  RTICdrStream_setBufferLength(stream, adjustedBufferLength);
 }
 
 RTIBool 
@@ -458,114 +465,65 @@ ConnextStaticRawDataPlugin_deserialize_sample(
     RTIBool deserialize_sample, 
     void *endpoint_plugin_qos)
 {
+  char * position = NULL;
+  RTIBool done = RTI_FALSE;
+
+  if (endpoint_data) {}   /* To avoid warnings */
+  if (endpoint_plugin_qos) {}   /* To avoid warnings */
+
+  /* This plugin can only be used to publish the top-level DDS Topic-Type
+   * in which case deserialize_encapsulation==TRUE. If that is not
+   * the case then it is an error.
+   */
+  if (!deserialize_encapsulation) {
+    return RTI_FALSE;
+  }
+
+  position = RTICdrStream_resetAlignment(stream);
+
+  /* TODO. The call does not belong here. It should be pushed
+   * inside RTICdrStream_deserializeAndSetCdrEncapsulation
+   */
+  ConnextStaticRawDataPlugin_remove_padding_from_stream(stream);
+
+  if (deserialize_sample) {
+    /* Note that sample->key_hash was already set by SerializedTypePlugin_deserialize()
+       it is done there because SerializedTypePlugin_deserialize_sample does not
+       have access to the SampleInfo where that information is
+    */
+
+    /* We do not set the serialized_key on deserialization */
+    DDS_OctetSeq_set_length(&sample->serialized_key, 0);
+
+    /* We copy everything that remains in the CDR stream */
+    int bytesLeftInStream = RTICdrStream_getRemainder(stream);
+    DDS_Octet * cdrBufferPtr = (DDS_Octet *) RTICdrStream_getCurrentPosition(stream);
+    if (cdrBufferPtr == NULL) {
+      goto fin;
+    }
 
-    char * position = NULL;
-
-    RTIBool done = RTI_FALSE;
-
-    try {
-
-        if (endpoint_data) {} /* To avoid warnings */
-        if (endpoint_plugin_qos) {} /* To avoid warnings */
-        if(deserialize_encapsulation) {
-
-            if (!RTICdrStream_deserializeAndSetCdrEncapsulation(stream)) {
-                return RTI_FALSE;
-            }
-
-            position = RTICdrStream_resetAlignment(stream);
-        }
-        if(deserialize_sample) {
-
-            ConnextStaticRawData_initialize_ex(sample, RTI_FALSE, RTI_FALSE);
-
-            if (!RTICdrStream_deserializePrimitiveArray(
-                stream, (void*) sample->key_hash, ((KEY_HASH_LENGTH_16)), RTI_CDR_OCTET_TYPE)) {
-                goto fin; 
-            }
-
-            {
-                RTICdrUnsignedLong sequence_length;
-                if (!RTICdrStream_lookUnsignedLong(stream,&sequence_length)) {
-                    goto fin; 
-                }
-                if (!DDS_OctetSeq_set_maximum(&sample->serialized_key,sequence_length)) {
-                    return RTI_FALSE;
-                }
-                if (DDS_OctetSeq_get_contiguous_bufferI(&sample->serialized_key) != NULL) {
-                    if (!RTICdrStream_deserializePrimitiveSequence(
-                        stream,
-                        DDS_OctetSeq_get_contiguous_bufferI(&sample->serialized_key),
-                        &sequence_length,
-                        DDS_OctetSeq_get_maximum(&sample->serialized_key),
-                        RTI_CDR_OCTET_TYPE)){
-                        goto fin; 
-                    }
-                } else {
-                    if (!RTICdrStream_deserializePrimitivePointerSequence(
-                        stream,
-                        (void **) DDS_OctetSeq_get_discontiguous_bufferI(&sample->serialized_key),
-                        &sequence_length,
-                        DDS_OctetSeq_get_maximum(&sample->serialized_key),
-                        RTI_CDR_OCTET_TYPE)){
-                        goto fin; 
-                    }
-                }
-                if (!DDS_OctetSeq_set_length(&sample->serialized_key, sequence_length)) {
-                    return RTI_FALSE;
-                }
-
-            }
-            {
-                RTICdrUnsignedLong sequence_length;
-                if (!RTICdrStream_lookUnsignedLong(stream,&sequence_length)) {
-                    goto fin; 
-                }
-                if (!DDS_OctetSeq_set_maximum(&sample->serialized_data,sequence_length)) {
-                    return RTI_FALSE;
-                }
-                if (DDS_OctetSeq_get_contiguous_bufferI(&sample->serialized_data) != NULL) {
-                    if (!RTICdrStream_deserializePrimitiveSequence(
-                        stream,
-                        DDS_OctetSeq_get_contiguous_bufferI(&sample->serialized_data),
-                        &sequence_length,
-                        DDS_OctetSeq_get_maximum(&sample->serialized_data),
-                        RTI_CDR_OCTET_TYPE)){
-                        goto fin; 
-                    }
-                } else {
-                    if (!RTICdrStream_deserializePrimitivePointerSequence(
-                        stream,
-                        (void **) DDS_OctetSeq_get_discontiguous_bufferI(&sample->serialized_data),
-                        &sequence_length,
-                        DDS_OctetSeq_get_maximum(&sample->serialized_data),
-                        RTI_CDR_OCTET_TYPE)){
-                        goto fin; 
-                    }
-                }
-                if (!DDS_OctetSeq_set_length(&sample->serialized_data, sequence_length)) {
-                    return RTI_FALSE;
-                }
+    /* Do not call SerializedType_initialize_ex initialize here
+       because it would override the key_hash field
+       SerializedType_initialize_ex(sample, RTI_FALSE, RTI_FALSE);
+     */
+    if (!DDS_OctetSeq_from_array(&sample->serialized_data, cdrBufferPtr, bytesLeftInStream) ) {
+      goto fin;
+    }
+    RTICdrStream_incrementCurrentPosition(stream, bytesLeftInStream);
+  }
 
-            }
-        }
+  done = RTI_TRUE;
 
-        done = RTI_TRUE;
-      fin:
-        if (done != RTI_TRUE && 
-        RTICdrStream_getRemainder(stream) >=
-        RTI_CDR_PARAMETER_HEADER_ALIGNMENT) {
-            return RTI_FALSE;   
-        }
-        if(deserialize_encapsulation) {
-            RTICdrStream_restoreAlignment(stream,position);
-        }
+fin:
+  if ( (done != RTI_TRUE) &&
+    (RTICdrStream_getRemainder(stream) >= RTI_CDR_PARAMETER_HEADER_ALIGNMENT) )
+  {
+    return RTI_FALSE;
+  }
 
-        return RTI_TRUE;
+  RTICdrStream_restoreAlignment(stream, position);
 
-    } catch (std::bad_alloc&) {
-        return RTI_FALSE;
-    }
+  return RTI_TRUE;
 }
 
 RTIBool
@@ -971,7 +929,9 @@ Key Management functions:
 PRESTypePluginKeyKind 
 ConnextStaticRawDataPlugin_get_key_kind(void)
 {
-    return PRES_TYPEPLUGIN_USER_KEY;
+    // TODO(karsten1987): Whenever we introduce keys for our data types
+    // this might have to change.
+    return PRES_TYPEPLUGIN_NO_KEY;
 }
 
 RTIBool 
@@ -1408,6 +1368,11 @@ ConnextStaticRawDataPlugin_serialized_sample_to_keyhash(
 * ------------------------------------------------------------------------ */
 struct PRESTypePlugin *ConnextStaticRawDataPlugin_new(void) 
 { 
+  return NULL;
+}
+
+struct PRESTypePlugin *ConnextStaticRawDataPlugin_new_external(struct DDS_TypeCode * external_type_code)
+{
     struct PRESTypePlugin *plugin = NULL;
     const struct PRESTypePluginVersion PLUGIN_VERSION = 
     PRES_TYPE_PLUGIN_VERSION_2_0;
@@ -1503,7 +1468,7 @@ struct PRESTypePlugin *ConnextStaticRawDataPlugin_new(void)
     (PRESTypePluginKeyToInstanceFunction)
     ConnextStaticRawDataPlugin_key_to_instance;
     plugin->serializedKeyToKeyHashFnc = NULL; /* Not supported yet */
-    plugin->typeCode =  (struct RTICdrTypeCode *)ConnextStaticRawData_get_typecode();
+    plugin->typeCode =  (struct RTICdrTypeCode *)external_type_code;
 
     plugin->languageKind = PRES_TYPEPLUGIN_CPP_LANG;
 
diff --git a/rmw_connext_cpp/resources/patch_generated/connext_static_raw_dataPlugin.h b/rmw_connext_cpp/resources/patch_generated/connext_static_raw_dataPlugin.h
index 89b4c67..bd23b77 100644
--- a/rmw_connext_cpp/resources/patch_generated/connext_static_raw_dataPlugin.h
+++ b/rmw_connext_cpp/resources/patch_generated/connext_static_raw_dataPlugin.h
@@ -324,6 +324,9 @@ extern "C" {
     NDDSUSERDllExport extern struct PRESTypePlugin*
     ConnextStaticRawDataPlugin_new(void);
 
+    NDDS_USER_DLL_EXPORT extern struct PRESTypePlugin*
+    ConnextStaticRawDataPlugin_new_external(struct DDS_TypeCode * external_type_code);
+
     NDDSUSERDllExport extern void
     ConnextStaticRawDataPlugin_delete(struct PRESTypePlugin *);
 
diff --git a/rmw_connext_cpp/resources/patch_generated/connext_static_raw_dataSupport.cxx b/rmw_connext_cpp/resources/patch_generated/connext_static_raw_dataSupport.cxx
index 83be31b..f2c9c63 100644
--- a/rmw_connext_cpp/resources/patch_generated/connext_static_raw_dataSupport.cxx
+++ b/rmw_connext_cpp/resources/patch_generated/connext_static_raw_dataSupport.cxx
@@ -115,3 +115,62 @@ Defines:   TTypeSupport, TData, TDataReader, TDataWriter
 #undef TPlugin_new
 #undef TPlugin_delete
 
+DDS_ReturnCode_t
+ConnextStaticRawDataSupport_register_external_type(
+  DDSDomainParticipant * participant,
+  const char * type_name,
+  struct DDS_TypeCode * type_code)
+{
+  DDSTypeSupport * dds_data_type = NULL;
+  struct PRESTypePlugin * presTypePlugin = NULL;
+  DDS_ReturnCode_t retcode = DDS_RETCODE_ERROR;
+  DDS_Boolean delete_data_type = DDS_BOOLEAN_FALSE;
+  RTIBool already_registered = RTI_FALSE;
+
+  if (type_code == NULL) {
+    goto finError;
+  }
+
+  if (participant == NULL) {
+    goto finError;
+  }
+
+  /* TODO pass the type_code */
+  presTypePlugin = ConnextStaticRawDataPlugin_new_external(type_code);
+  if (presTypePlugin == NULL) {
+    goto finError;
+  }
+
+  dds_data_type = new ConnextStaticRawDataTypeSupport(true);
+  if (dds_data_type == NULL) {
+    fprintf(stderr, "Error while registering external type\n");
+    goto finError;
+  }
+  delete_data_type = RTI_TRUE;
+
+  presTypePlugin->_userBuffer = (PRESWord *)dds_data_type;
+  already_registered = participant->is_type_registered(type_name);
+
+  retcode = participant->register_type(type_name, presTypePlugin, NULL, !already_registered);
+  if (retcode != DDS_RETCODE_OK) {
+    fprintf(stderr, "error while registering external type\n");
+    goto finError;
+  }
+
+  if (!already_registered) {
+    delete_data_type = DDS_BOOLEAN_FALSE;
+  }
+
+  retcode = DDS_RETCODE_OK;
+
+finError:
+  if (presTypePlugin != NULL) {
+    ConnextStaticRawDataPlugin_delete(presTypePlugin);
+  }
+  if (delete_data_type) {
+    delete (ConnextStaticRawDataTypeSupport *)dds_data_type;
+    dds_data_type = NULL;
+  }
+
+  return retcode;
+}
diff --git a/rmw_connext_cpp/resources/patch_generated/connext_static_raw_dataSupport.h b/rmw_connext_cpp/resources/patch_generated/connext_static_raw_dataSupport.h
index 012a1f6..51db529 100644
--- a/rmw_connext_cpp/resources/patch_generated/connext_static_raw_dataSupport.h
+++ b/rmw_connext_cpp/resources/patch_generated/connext_static_raw_dataSupport.h
@@ -44,13 +44,106 @@ implementing generics in C and C++.
 
 #endif
 
-DDS_TYPESUPPORT_CPP(
-    ConnextStaticRawDataTypeSupport, 
-    ConnextStaticRawData);
+class NDDSUSERDllExport DDSCPPDllExport ConnextStaticRawDataTypeSupport : public ::DDSTypeSupport
+{
+public:
+  ConnextStaticRawDataTypeSupport(bool osrf)
+  {
+    (void) osrf;
+  }
+
+  ~ConnextStaticRawDataTypeSupport();
+
+  static DDS_ReturnCode_t register_type(
+    DDSDomainParticipant * participant,
+    const char * type_name = "ConnextStaticRawData");
+
+  static DDS_ReturnCode_t unregister_type(
+    DDSDomainParticipant * participant,
+    const char * type_name = "ConnextStaticRawData");
+
+  static const char * get_type_name();
+
+  static ConnextStaticRawData * create_data_ex(DDS_Boolean allocatePointers);
+
+  static ConnextStaticRawData * create_data(
+    const DDS_TypeAllocationParams_t & alloc_params =
+    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT);
+
+  static DDS_ReturnCode_t delete_data_ex(
+    ConnextStaticRawData * a_data,
+    DDS_Boolean deletePointers);
+
+  static DDS_ReturnCode_t delete_data(
+    ConnextStaticRawData * a_data,
+    const DDS_TypeDeallocationParams_t & dealloc_params =
+    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT);
+
+  static void print_data(const ConnextStaticRawData * a_data);
+
+  static DDS_ReturnCode_t copy_data(
+    ConnextStaticRawData * dst_data, const ConnextStaticRawData * src_data);
+
+  static DDS_ReturnCode_t initialize_data_ex(
+    ConnextStaticRawData * a_data,
+    DDS_Boolean allocatePointers);
+
+  static DDS_ReturnCode_t initialize_data(
+    ConnextStaticRawData * a_data,
+    const DDS_TypeAllocationParams_t & alloc_params =
+    DDS_TYPE_ALLOCATION_PARAMS_DEFAULT);
+
+  static DDS_ReturnCode_t finalize_data_ex(
+    ConnextStaticRawData * a_data,
+    DDS_Boolean deletePointers);
+
+  static DDS_ReturnCode_t finalize_data(
+    ConnextStaticRawData * a_data,
+    const DDS_TypeDeallocationParams_t & dealloc_params =
+    DDS_TYPE_DEALLOCATION_PARAMS_DEFAULT);
+
+  DDSDataReader * create_datareaderI(DDSDataReader * dataReader);
+
+  DDS_ReturnCode_t destroy_datareaderI(DDSDataReader * dataReader);
+
+  DDSDataWriter * create_datawriterI(DDSDataWriter * dataWriter);
+
+  DDS_ReturnCode_t destroy_datawriterI(DDSDataWriter * dataWriter);
+
+  static DDS_TypeCode * get_typecode();
+
+  static DDS_ReturnCode_t serialize_data_to_cdr_buffer(
+    char * buffer,
+    unsigned int & length,
+    const ConnextStaticRawData * a_data);
+
+  static DDS_ReturnCode_t deserialize_data_from_cdr_buffer(
+    ConnextStaticRawData * a_data,
+    const char * buffer,
+    unsigned int length);
+
+  static DDS_ReturnCode_t data_to_string(
+    ConnextStaticRawData * sample,
+    char * str,
+    DDS_UnsignedLong & str_size,
+    const DDS_PrintFormatProperty & property);
+
+  static void finalize();
+
+private:
+  ConnextStaticRawDataTypeSupport();
+};
 
 DDS_DATAWRITER_CPP(ConnextStaticRawDataDataWriter, ConnextStaticRawData);
 DDS_DATAREADER_CPP(ConnextStaticRawDataDataReader, ConnextStaticRawDataSeq, ConnextStaticRawData);
 
+NDDSUSERDllExport
+DDS_ReturnCode_t
+ConnextStaticRawDataSupport_register_external_type(
+  DDSDomainParticipant * participant,
+  const char * type_name,
+  struct DDS_TypeCode * type_code);
+
 #if (defined(RTI_WIN32) || defined (RTI_WINCE)) && defined(NDDS_USER_DLL_EXPORT)
 /* If the code is building on Windows, stop exporting symbols.
 */
-- 
2.12.0

